COLLECT performance data over time:
  - Page load times (TTFB, FCP, LCP)
  - API response times by endpoint
  - Database query performance
  - Server resource utilization
  - Client-side performance metrics
  - Error rates and types
  - Third-party service latencies
SET UP data aggregation:
  - Define time buckets (hourly, daily)
  - Calculate percentiles (p50, p95, p99)
  - Group by key dimensions
  - Remove outliers appropriately
  - Handle missing data points
  - Normalize for traffic volume
ANALYZE performance patterns:
  - Identify degradation trends
  - Find periodic patterns (time of day, day of week)
  - Correlate with deployment timeline
  - Compare across user segments
  - Identify seasonal impacts
  - Detect sudden changes
INVESTIGATE root causes:
  - Map performance changes to code changes
  - Identify resource bottlenecks
  - Find correlation with traffic spikes
  - Check infrastructure changes
  - Review third-party service impacts
  - Analyze database growth effects
CALCULATE business impact:
  - User experience scores
  - Conversion rate correlation
  - Revenue impact estimates
  - User satisfaction changes
  - Support ticket correlation
  - Abandonment rates
CREATE performance forecasts:
  - Project future performance
  - Identify when limits will be hit
  - Plan capacity needs
  - Estimate optimization ROI
  - Predict user impact
SET UP automated monitoring:
  - Define performance budgets
  - Configure trend alerts
  - Create anomaly detection
  - Set up dashboards
  - Implement SLA tracking
  - Schedule regular reports
RECOMMEND optimizations:
  - Prioritize by impact and effort
  - Quick wins vs long-term fixes
  - Infrastructure scaling needs
  - Code optimization opportunities
  - Caching strategies
  - Architecture improvements
GENERATE trend report with:
  - Executive summary of performance health
  - Visual trend charts
  - Critical issues identified
  - Optimization roadmap
  - Resource requirements
  - Success metrics
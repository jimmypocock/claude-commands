SCAN the codebase for indicators of technical debt:
  - TODO, FIXME, HACK, and XXX comments
  - Deprecated dependencies and outdated packages
  - Code complexity metrics (cyclomatic complexity, file length)
  - Test coverage gaps
  - Duplicated code blocks
  - Outdated documentation
  - Security vulnerabilities in dependencies
  - Performance bottlenecks identified in monitoring
CATEGORIZE technical debt by type:
  - Architecture debt (poor structure, tight coupling)
  - Code debt (complexity, duplication, poor naming)
  - Test debt (missing tests, flaky tests, slow tests)
  - Documentation debt (outdated, missing, unclear)
  - Dependency debt (outdated, vulnerable, unnecessary)
  - Infrastructure debt (manual processes, missing monitoring)
  - Performance debt (unoptimized queries, memory leaks)
ASSESS impact and effort for each item:
  - Impact on development velocity
  - Risk of bugs or security issues
  - Effect on system performance
  - Developer experience impact
  - Estimated effort to resolve (hours/days/weeks)
  - Dependencies and blockers
CALCULATE technical debt metrics:
  - Total "debt" in developer hours
  - Debt ratio (debt time / development time)
  - Interest rate (ongoing cost of not fixing)
  - Break-even point for each fix
CREATE a prioritized remediation plan:
  - Quick wins (high impact, low effort)
  - Critical issues (security, data integrity)
  - Velocity improvements (things slowing team down)
  - Long-term refactoring projects
  - Items to address during feature work
GENERATE a technical debt report including:
  - Executive summary with key metrics
  - Top 10 priority items with justification
  - Remediation roadmap with timeline
  - Resource requirements
  - Risk assessment if debt is not addressed
  - Success metrics to track improvement